#!/bin/bash

# exit when any command fails
set -e

function create_minikube {
    minikube start \
    --driver=kvm2 \
    --disk-size='50000mb' \
    --cpus='4' \
    --memory='16384mb' \
    --kubernetes-version='1.16.9' 

    sleep 5

    minikube addons enable metallb
}

function start_dashboard {
    echo "starting dashboard"
    cd dashboard
    skaffold run
    cd ..
}

function start_casa_account_v1 {
    echo "starting casa-account-v1"
    cd casa-account-v1
    skaffold run
    cd ..
}

function start_casa_account_v2 {
    echo "starting casa-account-v2"
    cd casa-account-v2
    skaffold run
    cd ..
}

function start_load_generator {
    echo "starting load-generator"
    cd load-generator
    skaffold run
    cd ..
}


if [ "$1" = "--minikube" ]; then
    create_minikube

    echo 
    echo now manually install istio to minikube, e.g.
    echo
    echo     istioctl manifest apply --set profile=demo --set values.tracing.enabled=true --set values.pilot.traceSampling=100
    echo
    echo wait a while for istio to finish install and stabalizes, 
    echo then rerun this script without --minikube flag to install demo application

    exit 0
fi

source common.sh
get_ingress_addr

[ -z "$CTX" ] && exit 1

if [ "$CTX" = "gke1" ]; then
    APP_ENV=gke
else 
    APP_ENV=local
fi

# create namespace for deploying the demo app
APP_NAMESPACE=$(kubectl apply -f istio/envs/${APP_ENV}/namespace.yaml -o name | cut -d '/' -f 2)
if [ -z "$APP_NAMESPACE" ]; then
    echo unable to create namespace using env $APP_ENV
    exit 1
fi

# creating secret for cassandra database
kustomize build . | kubectl apply -n $APP_NAMESPACE -f -

# starting services
start_dashboard
start_casa_account_v1
start_casa_account_v2

if [ "$1" == "--load" ]; then
    start_load_generator
fi

cd istio
./apply

kubectl get pods -n $APP_NAMESPACE

