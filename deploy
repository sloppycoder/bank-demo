#!/bin/bash

# exit when any command fails
set -e

function create_minikube {
    minikube start \
    --driver=kvm2 \
    --disk-size='50000mb' \
    --cpus='2' \
    --memory='16384mb' \
    --kubernetes-version='1.16.8' 
}

function start_dashboard {
    echo "starting dashboard"
    cd dashboard
    skaffold run
    cd ..
}

function start_casa_account_v1 {
    echo "starting casa-account-v1"
    cd casa-account-v1
    skaffold run
    cd ..
}

function start_casa_account_v2 {
    echo "starting casa-account-v2"
    cd casa-account-v2
    skaffold run
    cd ..
}

function start_load_generator {
    echo "starting load-generator"
    cd load-generator
    skaffold run
    cd ..
}


if [ "$1" = "--minikube" ]; then
    create_minikube

    echo 
    echo now manually install istio to minikube, e.g.
    echo
    echo istioctl manifest apply \
    echo      --set profile=demo \
    echo      --set values.global.mtls.auto=true \
    echo      --set values.global.mtls.enabled=true
    echo
    echo wait a while for istio to finish install and stabalizes, 
    echo then rerun this script without --minikube flag to install demo application

    exit 0
fi

source common.sh
get_ingress_addr

[ -z "$CTX" ] && exit 1

if [ "$CTX" = "gke1" ]; then
    APP_ENV=gke
else 
    APP_ENV=local
fi

# create namespace for deploying the demo app
APP_NAMESPACE=$(kubectl apply -f istio/envs/${APP_ENV}/namespace.yaml -o name | cut -d '/' -f 2)
if [ -z "$APP_NAMESPACE" ]; then
    echo unable to create namespace using env $APP_ENV
    exit 1
fi

# creating secret for cassandra database
kustomize build . | kubectl apply -n $APP_NAMESPACE -f -

# starting services
start_dashboard
start_casa_account_v1
start_casa_account_v2

if [ "$1" == "--load" ]; then
    start_load_generator
fi

cd istio
./apply

kubectl config set-context $CTX --namespace $APP_NAMESPACE
kubectl get pods

echo
echo sending a test request to endpoint
cd ../load-generator
./e

cd ..

